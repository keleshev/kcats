+: '+' generic .
pr: 'pr' generic .
eq: 'eq' generic .

(: '(' '(' type-set .

(.pr: '(' pr . 
str.pr: builtin.str.pr .
float.+: builtin.float.+ .
   
generic:    
    [2]     | 1 2 '+' 2
    type    | 1 2 '+' 'float'
    swp     | 1 2 'float' '+' 
    '.'     | 1 2 'float' '+' '.'
    swp     | 1 2 'float' '.' '+'
    str.&   | 1 2 'float' '.+'
    str.&   | 1 2 'float.+'
    eval .  | 3

generic:
    [2] type swp '.' swp str.& str.& eval .

generic:
    eval(str.&(type($1) '.' $2) $3 $4)
                    
generic:    
    [2]     | 'a' 'b' '+' 'b'
    type    | 'a' 'b' '+' 'str'
    swp     | 'a' 'b' 'str' '+' 
    str.&   | 'a' 'b' 'str+'
    eval .  | 'ab'

( )+: 
    if [2] type '(' == : swp x .
    else + )+ . 

( )+: '+' vararg .

vararg:   
    if [3] type '(' == : x swp x .
    else d -> eval ')' <- str.+ eval .



sign: 
    if [1] 0 > then x +1 return
    if [1] 0 < then x -1 return
                       0 return    

sign: 
    if [1] 0 > : x +1 .
    if [1] 0 < : x -1 .
                 0 .   

sign: 
    if [1] 0 > then 
        x +1 
    else if [1] 0 < then 
        x -1 
    else 0 end if 
    return 
     
sign: 
    if [1] 0 > : 
        x +1 
    elif [1] 0 < : 
        x -1 
    else 0 ; 
    return 

sign: 
    [1] 0 > : x +1 .
    [1] 0 < : x -1 .
              0 .    
sign: 
    [1] 0 > : x +1 ,
    [1] 0 < : x -1 ,
              0 ; .

fact: [1] 0 == then fact(0) [1] 1 == then return fact(n) return
fact(0): x 1 return
fact(n): [1] 1 - fact * return

fact 0 = 1
fact n = n * fact (n - 1)

fact: 
    [1] 0 == then: x 1 
             else: [1] 1 - fact * .
fact: 
    [1] 0 == then: x 1 . 
                   [1] 1 - fact * .
fact: 
    [1] 0 == : x 1 . 
  x [1] 1 == :           [1] 1 - fact * .
             

nand: built-in
dup: [1]
dup2: [2] [1]
xor: dup nand swp [2] nand swp [3] nand nand swp x
xnor: xor not
