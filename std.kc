################################################################################
#                       --- kcats standard library ---
# 
# Syntax:
# 
#     <command> 
#         Enter a textual <command> or several to execute on stack.
#         E.g. `fact` command will yield factorial of top-of-stack.
# 
#     <number>
#         Enter a <number> to push it on stack.
#         E.g. `1 500 10e-35 inf nan` will push the corresponding
#         floating-point values on stack.
# 
#     [<number>] 
#         Push a copy of <number>-th element on stack.
#         E.g. if stack consist of `2 4 8`, [1] will push the first
#         number (8) on top of stack: `2 4 8 8`.
# 
#     <name>: <commands> return 
#         Definition of <name> command, <commands> will be executed 
#         until 'return' keyword is encountered.
# 
#     if <condition> then <commands> return <other-commands>
#         If <condition> commands yields a non-zero value, 
#         then <commands> are executed until 'return' is encounterd;
#         if <condition> yields zero value, <other-commands> are
#         executed (commands after the closest 'return').
# 
#     . (i.e. dot) 
#         A short synonim for 'return' keyword.
#     
#     : (i.e. colon)
#         A short synonim for 'then' keyword.                
#     
#     <filename>.kc (TODO implement)
#         Load definitions from .kc file with <filename>-name.
#         E.g. 'math.kc' will load file math.kc from current directory.
#     
#     # (i.e. hash)
#         Unconditional jump til next newline character.
#         Could be used for comments.
# 
# Special commands:
#     q - quit kcats.
#     context - show executing context (definitions).
#     help - same as 'context' (TODO implement).
#     c - clear stack.
#     x - delete/pop top element from stack.
#     swp - swap two top elements on stack.
# 
# Builtins:
#     +  (sum)
#     ^  (power)
#     *  (product)
#     /  (division)
#     >  (greater-than)

# 
# Standard definitons:
#

# Constants:

true:  1 . 
false: 0 . 

e:  2.71822 . 
pi: 3.14159 . 

# Syntactic sugar for duplication-d and deletion-x

d: [1] .
dd: [2] [2] .
ddd: [3] [3] [3] .
xx: x x .
xxx: x x x .


# Logical operations:

not:  0 == .  
!:    not .         # '!' short for 'not'
bool: not not . 
and:  * bool . 
or:   ! swp ! and ! .
nor: or not .


if:   .     # Guess why 'if' and 'else'
else: .     # have such strange definitions?
pass: .

# Comparison operators:

<:  swp > .      # less-than
>=: < ! .
<=: > ! .
==: 
    if [2] [2] > : x x false . 
    if [2] [2] < : x x false . 
                   x x true  .
!=: == ! .      # not equal


# Math:

-: -1 * + .    # substraction
max: 
    if [2] [2] > : x . swp x .
min:
    if [2] [2] < : x . swp x .
sign: 
    if [1] 0 > : x +1 .
    if [1] 0 < : x -1 . 
            else x  0 .
abs: 2 ^ 0.5 ^ .


# Assert equal (draft, requires strings):
# 
# assert: 
#   if [2] [2] == : x .     # if equal - do nothing
#   else "assert error " pr pr " != " pr pr .     

# Factorial - long version

factor: 
    if [1] 0 == then        
        x 1                 
    return
    else                    
        [1] 1 - factor *    
    return


# Fact. shrt. ver.

fact: [1] 0 == : x 1 .                  
                 [1] 1 - fact * .                  

# Note that factorial versions above are identical
# except for keywords usage.


# Fibonacci function

fib:
    if [1] 0 == : pass .
    if [1] 1 == : pass .
  else [1] 1 - fib swp 2 - fib + .






